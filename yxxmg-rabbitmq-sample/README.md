# springboot rabbitmq

### 消息模式

1. fanout 发布订阅模式
   是一种广播机制，它是没有路由key的模式
2. direct 路由模式
   是fannout模式上的一种叠加，增加了路由RoutingKey的模式
3. topic 主题模式
   是direct模式上的一种叠加，增加了模糊路由RoutingKey的模式
4. work 工作模式
   当有多个消费者时，我们的消费会被哪个消费者消费呢？我们该如何均衡消费者消费信息的多少呢？
   轮询模式：一个消费者一条，按均分发
   公平分发: 根据消费者消费能力进行公平分发，处理快的处理的快，处理慢的处理的少，按劳分配

### 消息可靠性投递

生产者->交换机->队列->消费者

三种模式来监听消息投递成功：

- 确认模式(Confirm)：可以监听消息是否从生产者成功传递到交换机。
- 退回模式(Return)：可以监听消息是否从交换机成功传递到队列。
- 消费者确认消息(Consumer Ack): 可以监听消费者是否成功处理消息。

### 生产者模块配置

`spring.rabbitmq.publisher-confirm-type`

- `correlated` 发布消息成功到交换器后会触发回调方法，一般使用此值
- `none` 禁用发布确认模式，默认值
- `simple` 简单使用

CORRELATED 和 SIMPLE 的区别：

    CORRELATED：发布者将收到一个带有确认标识 的确认消息，该标识与发布的每个消息相关联。这种模式可以确保每个消息被确认，但需要在发送和接收确认之间进行映射。
    SIMPLE：发布者将仅收到一条确认消息，表示所有消息都已经成功发布。这种模式相对简单，但不能保证每个消息都成功确认。
### 优先级队列

### 死信队列

在 MQ 中，当消息在队列中由于某些原因没有被及时消费而变成死信（Dead Message）后，消息中间件可以将其从当前队列发送到另一个队列中，这个队列就是死信队列。而在 RabbitMQ 中，由于有交换机的概念，实际是将死信发送给了死信交换机（Dead Letter Exchange，简称DLX）。

**死信交换机 和 死信队列与普通的没有区别。**

死信队列只是一种特殊的队列，里面的消息仍然可以消费。

消息成为死信的情况：

- 队列消息长度到达限制
- 消费者拒签消息，并且不把消息重新放入原队列
- 消息到达存活时间未被消费

### 延迟队列

延迟队列，即消息进入队列后不会立即被消费，只有到达指定时间后，才会被消费。

但 RabbitMQ 中并未提供延迟队列功能，我们可以使用死信队列实现延迟队列的效果。

> 延迟队列：TTL + 死信队列的合体

#### 1. 死信队列实现

我们可以使用死信队列来实现延迟队列的功能，大致代码同上面死信队列代码一致，不过我们需要加一个专门监听死信队列的消费者，将超时的消息处理掉即可。

```java
@Component
@Slf4j
public class DeadConsumer {

    @RabbitListener(queues = "deadQueue")
    public void receiveD(Message message, Channel channel){
        String msg = new String(message.getBody());
        log.info("当前时间{}，收到死信队列的消息：{}", new Date(), msg);
    }
}
```

#### 2. MQ插件实现

在使用死信队列实现延迟队列时，会遇到一个问题：RabbitMQ只会移除队列顶端的过期消息，如果第一个消息的存活时长较长，而第二个消息的存活时长较短，则第二个消息并不会及时执行。
